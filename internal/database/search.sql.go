// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const searchApplicationsByName = `-- name: SearchApplicationsByName :many
SELECT a.id, a.project_id, a.name, a.status, a.description, a.repo_url, a.metadata, a.created_at, a.updated_at, p.name AS project_name
FROM applications a
JOIN projects p ON a.project_id = p.id
WHERE a.name = $1
`

type SearchApplicationsByNameRow struct {
	ID          int32
	ProjectID   int32
	Name        string
	Status      string
	Description sql.NullString
	RepoUrl     sql.NullString
	Metadata    pqtype.NullRawMessage
	CreatedAt   time.Time
	UpdatedAt   time.Time
	ProjectName string
}

func (q *Queries) SearchApplicationsByName(ctx context.Context, name string) ([]SearchApplicationsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchApplicationsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchApplicationsByNameRow
	for rows.Next() {
		var i SearchApplicationsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Status,
			&i.Description,
			&i.RepoUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchApplicationsByNamePattern = `-- name: SearchApplicationsByNamePattern :many
SELECT a.id, a.project_id, a.name, a.status, a.description, a.repo_url, a.metadata, a.created_at, a.updated_at, p.name AS project_name
FROM applications a
JOIN projects p ON a.project_id = p.id
WHERE a.name ~ ($1::text)
ORDER BY p.name, a.name
`

type SearchApplicationsByNamePatternRow struct {
	ID          int32
	ProjectID   int32
	Name        string
	Status      string
	Description sql.NullString
	RepoUrl     sql.NullString
	Metadata    pqtype.NullRawMessage
	CreatedAt   time.Time
	UpdatedAt   time.Time
	ProjectName string
}

func (q *Queries) SearchApplicationsByNamePattern(ctx context.Context, dollar_1 string) ([]SearchApplicationsByNamePatternRow, error) {
	rows, err := q.db.QueryContext(ctx, searchApplicationsByNamePattern, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchApplicationsByNamePatternRow
	for rows.Next() {
		var i SearchApplicationsByNamePatternRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Status,
			&i.Description,
			&i.RepoUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchApplicationsByStatus = `-- name: SearchApplicationsByStatus :many
SELECT a.id, a.project_id, a.name, a.status, a.description, a.repo_url, a.metadata, a.created_at, a.updated_at, p.name AS project_name
FROM applications a
JOIN projects p ON a.project_id = p.id
WHERE a.status = $1
ORDER BY p.name, a.name
`

type SearchApplicationsByStatusRow struct {
	ID          int32
	ProjectID   int32
	Name        string
	Status      string
	Description sql.NullString
	RepoUrl     sql.NullString
	Metadata    pqtype.NullRawMessage
	CreatedAt   time.Time
	UpdatedAt   time.Time
	ProjectName string
}

func (q *Queries) SearchApplicationsByStatus(ctx context.Context, status string) ([]SearchApplicationsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, searchApplicationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchApplicationsByStatusRow
	for rows.Next() {
		var i SearchApplicationsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Status,
			&i.Description,
			&i.RepoUrl,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectsByMetadata = `-- name: SearchProjectsByMetadata :many
SELECT id, name, status, link, description, metadata, created_at, updated_at
FROM projects
WHERE metadata @> ($1::jsonb)
ORDER BY name
`

func (q *Queries) SearchProjectsByMetadata(ctx context.Context, dollar_1 json.RawMessage) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectsByMetadata, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectsByName = `-- name: SearchProjectsByName :many
SELECT id, name, status, link, description, metadata, created_at, updated_at
FROM projects
WHERE name = $1
`

func (q *Queries) SearchProjectsByName(ctx context.Context, name string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectsByNamePattern = `-- name: SearchProjectsByNamePattern :many
SELECT id, name, status, link, description, metadata, created_at, updated_at
FROM projects
WHERE name ~ ($1::text)
ORDER BY name
`

func (q *Queries) SearchProjectsByNamePattern(ctx context.Context, dollar_1 string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectsByNamePattern, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectsByStatus = `-- name: SearchProjectsByStatus :many
SELECT id, name, status, link, description, metadata, created_at, updated_at
FROM projects
WHERE status = $1
ORDER BY name
`

func (q *Queries) SearchProjectsByStatus(ctx context.Context, status string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchReleasesByName = `-- name: SearchReleasesByName :many
SELECT pv.id, pv.project_id, pv.version, pv.description, pv.created_at, p.name AS project_name
FROM project_versions pv
JOIN projects p ON pv.project_id = p.id
WHERE pv.version = $1
`

type SearchReleasesByNameRow struct {
	ID          int32
	ProjectID   int32
	Version     string
	Description sql.NullString
	CreatedAt   time.Time
	ProjectName string
}

func (q *Queries) SearchReleasesByName(ctx context.Context, version string) ([]SearchReleasesByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchReleasesByName, version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchReleasesByNameRow
	for rows.Next() {
		var i SearchReleasesByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Version,
			&i.Description,
			&i.CreatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchReleasesByPattern = `-- name: SearchReleasesByPattern :many
SELECT pv.id, pv.project_id, pv.version, pv.description, pv.created_at, p.name AS project_name
FROM project_versions pv
JOIN projects p ON pv.project_id = p.id
WHERE pv.version ~ ($1::text)
ORDER BY p.name, pv.created_at DESC
`

type SearchReleasesByPatternRow struct {
	ID          int32
	ProjectID   int32
	Version     string
	Description sql.NullString
	CreatedAt   time.Time
	ProjectName string
}

func (q *Queries) SearchReleasesByPattern(ctx context.Context, dollar_1 string) ([]SearchReleasesByPatternRow, error) {
	rows, err := q.db.QueryContext(ctx, searchReleasesByPattern, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchReleasesByPatternRow
	for rows.Next() {
		var i SearchReleasesByPatternRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Version,
			&i.Description,
			&i.CreatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVersionsByGitHash = `-- name: SearchVersionsByGitHash :many
SELECT av.id, av.application_id, av.version, av.status, av.git_hash, av.description, av.metadata, av.created_at, a.name AS app_name, p.name AS project_name
FROM application_versions av
JOIN applications a ON av.application_id = a.id
JOIN projects p ON a.project_id = p.id
WHERE av.git_hash = $1
`

type SearchVersionsByGitHashRow struct {
	ID            int32
	ApplicationID int32
	Version       string
	Status        sql.NullString
	GitHash       sql.NullString
	Description   sql.NullString
	Metadata      pqtype.NullRawMessage
	CreatedAt     time.Time
	AppName       string
	ProjectName   string
}

func (q *Queries) SearchVersionsByGitHash(ctx context.Context, gitHash sql.NullString) ([]SearchVersionsByGitHashRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVersionsByGitHash, gitHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVersionsByGitHashRow
	for rows.Next() {
		var i SearchVersionsByGitHashRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Status,
			&i.GitHash,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.AppName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVersionsByName = `-- name: SearchVersionsByName :many
SELECT av.id, av.application_id, av.version, av.status, av.git_hash, av.description, av.metadata, av.created_at, a.name AS app_name, p.name AS project_name
FROM application_versions av
JOIN applications a ON av.application_id = a.id
JOIN projects p ON a.project_id = p.id
WHERE av.version = $1
`

type SearchVersionsByNameRow struct {
	ID            int32
	ApplicationID int32
	Version       string
	Status        sql.NullString
	GitHash       sql.NullString
	Description   sql.NullString
	Metadata      pqtype.NullRawMessage
	CreatedAt     time.Time
	AppName       string
	ProjectName   string
}

func (q *Queries) SearchVersionsByName(ctx context.Context, version string) ([]SearchVersionsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVersionsByName, version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVersionsByNameRow
	for rows.Next() {
		var i SearchVersionsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Status,
			&i.GitHash,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.AppName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVersionsByPattern = `-- name: SearchVersionsByPattern :many
SELECT av.id, av.application_id, av.version, av.status, av.git_hash, av.description, av.metadata, av.created_at, a.name AS app_name, p.name AS project_name
FROM application_versions av
JOIN applications a ON av.application_id = a.id
JOIN projects p ON a.project_id = p.id
WHERE av.version ~ ($1::text)
ORDER BY p.name, a.name, av.created_at DESC
`

type SearchVersionsByPatternRow struct {
	ID            int32
	ApplicationID int32
	Version       string
	Status        sql.NullString
	GitHash       sql.NullString
	Description   sql.NullString
	Metadata      pqtype.NullRawMessage
	CreatedAt     time.Time
	AppName       string
	ProjectName   string
}

func (q *Queries) SearchVersionsByPattern(ctx context.Context, dollar_1 string) ([]SearchVersionsByPatternRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVersionsByPattern, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVersionsByPatternRow
	for rows.Next() {
		var i SearchVersionsByPatternRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Status,
			&i.GitHash,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.AppName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVersionsByStatus = `-- name: SearchVersionsByStatus :many
SELECT av.id, av.application_id, av.version, av.status, av.git_hash, av.description, av.metadata, av.created_at, a.name AS app_name, p.name AS project_name
FROM application_versions av
JOIN applications a ON av.application_id = a.id
JOIN projects p ON a.project_id = p.id
WHERE av.status = $1
ORDER BY p.name, a.name, av.created_at DESC
`

type SearchVersionsByStatusRow struct {
	ID            int32
	ApplicationID int32
	Version       string
	Status        sql.NullString
	GitHash       sql.NullString
	Description   sql.NullString
	Metadata      pqtype.NullRawMessage
	CreatedAt     time.Time
	AppName       string
	ProjectName   string
}

func (q *Queries) SearchVersionsByStatus(ctx context.Context, status sql.NullString) ([]SearchVersionsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVersionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVersionsByStatusRow
	for rows.Next() {
		var i SearchVersionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Status,
			&i.GitHash,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.AppName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
